[gd_scene load_steps=2 format=3 uid="uid://cors4pgqhn0ig"]

[sub_resource type="GDScript" id="GDScript_1vrqt"]
script/source = "extends Node2D

@export var size := Vector2(200, 200)
@export var cell_size := Vector2.ONE * 100
@export var color : Color = Color.GRAY
@export var grid_thickness := 8.0
@export var outline_thickness := 0.0
@export var enabled : bool = true

@export_enum('square', 'triangular') var type = \"square\"


var active_points = []
var grid = []
var lines = []
var v_cells : int
var h_cells : int

var offset : Vector2 # this acts like position, but without altering the node's transform

var mesh : ImmediateMesh

const max_velocity = 4000

# Iterates through x and y axis, adding cells for each iteration
func init_grid():
	set_process(enabled)
	if not enabled:
		return
	
	v_cells = ceil(size.y/cell_size.y) + 1
	h_cells = ceil(size.x/cell_size.x) + 1 
	
	var size = cell_size * Vector2(h_cells-1, v_cells-1)
	offset = -size/2.0
	
	var lines_amount # populate the array of lines according to tiling type
	if type == 'square':
		lines_amount = h_cells + v_cells
	elif type == 'triangular':
		lines_amount = h_cells + h_cells + v_cells
	
	# Temporarily store the cells so we can set their neighbors that they'll draw to
	grid.resize(v_cells)
	for y in v_cells:
		grid[y] = []
		grid[y].resize(h_cells)
		for x in h_cells:
			grid[y][x] = Point.new(cell_size * Vector2(x+(0 if type == 'square' else 0.5*(y%2)), y) + offset, Vector2(x, y))
	lines.resize(lines_amount)
	# Init grid lines
	# Vertical Rows
	for x in h_cells:
		var line = Line2D.new()
		line.light_mask = 3
		#line.position = offset
		add_child(line)
		line.width = grid_thickness
		line.default_color = color
		for y in v_cells:
			line.add_point(grid[y][x].position)
		lines[x] = line
		
	if type == 'triangular':
		for x in range(1,h_cells):
			var line = Line2D.new()
			line.light_mask = 3
			#line.position = offset
			add_child(line)
			line.width = grid_thickness
			line.default_color = color
			for y in v_cells:
				line.add_point(grid[y][x-y%2].position)
			lines[h_cells + x] = line
		
	for y in v_cells:
		var line = Line2D.new()
		line.light_mask = 3
		#line.position = offset
		add_child(line)
		line.width = grid_thickness
		line.default_color = color
		for x in h_cells:
			line.add_point(grid[y][x].position)
		lines[h_cells + (0 if type == 'square' else h_cells) + y] = line
		
	if outline_thickness > 0.01:
		%Outline.width = outline_thickness
		%Outline.default_color = color
		%Outline.set_points(PackedVector2Array([
			Vector2(-size.x/2,-size.y/2),
			Vector2( size.x/2,-size.y/2),
			Vector2( size.x/2 ,size.y/2),
			Vector2(-size.x/2, size.y/2)
		]))
	else:
		%Outline.queue_free()
	
const MULTIPLIER = 0.25
var count_frame = 0

func _process(delta):
	count_frame += 1
	if count_frame % 2:
		return
	var gravity_wells = get_tree().get_nodes_in_group(\"gravity_wells\")
	for well in gravity_wells:
		if abs(well.get_gravity() * MULTIPLIER) <= 1: continue
		var index = (to_local(well.global_position) - offset).snapped(cell_size) / cell_size
		var radius = well.get_influence_radius() / cell_size.x + 1
		for y in range(index.y - radius, index.y + radius):
			for x in range(index.x - radius, index.x + radius):
				if x <= 0 || x >= h_cells - 1 || y <= 0 || y >= v_cells - 1: continue
				var point = grid[y][x]
				if active_points.has(point): continue
				var dist = 0#(well.global_position - point.position).length()
				if dist < well.get_influence_radius():
					active_points.append(point)
	for point in active_points:
		point.process(delta, gravity_wells, global_transform)
		if point.is_at_rest():
			point.rest()
			active_points.erase(point)
		# Update lines
		lines[point.index.x].set_point_position(point.index.y, point.position)
		if type == 'square':
			lines[h_cells + point.index.y].set_point_position(point.index.x, point.position)
		elif type == 'triangular':
			var squiggly_y = point.index.x+(int(point.index.y)%2)
			if squiggly_y < h_cells:
				lines[h_cells + squiggly_y].set_point_position(point.index.y, point.position)
			lines[h_cells + h_cells + point.index.y].set_point_position(point.index.x, point.position)
			
	# MESH SUPPORT
	#mesh.clear_surfaces()
	#mesh.surface_begin(Mesh.PRIMITIVE_TRIANGLES)
	#for x in range(h_cells-1):
		#for y in range(v_cells-1):
			##if (x+y) % 2:
			##	continue
			#mesh.surface_add_vertex(Vector3(grid[y][x].x(), grid[y][x].y(), 0))
			#mesh.surface_add_vertex(Vector3(grid[y][x+1].x(), grid[y][x+1].y(), 0))
			#mesh.surface_add_vertex(Vector3(grid[y+1][x].x(), grid[y+1][x].y(), 0))
			#
			##mesh.surface_add_vertex(Vector3(grid[y+1][x+1].x(), grid[y+1][x+1].y(), 0))
			##mesh.surface_add_vertex(Vector3(grid[y][x+1].x(), grid[y][x+1].y(), 0))
			##mesh.surface_add_vertex(Vector3(grid[y+1][x].x(), grid[y+1][x].y(), 0))
	#mesh.surface_end()


class Point:
	var velocity := Vector3.ZERO
	var position_3d : Vector3
	var anchor : Vector3
	
	var index : Vector2
	var position : Vector2
	
	func _init(position, index):
		self.position = position
		self.index = index
		anchor = Vector3(position.x, position.y, 0.0)
		position_3d = anchor
	
	func process(delta, gravity_wells, global_transform):
		# elastic velocity
		var diff = anchor - position_3d
		var desired_velocity = diff * 24
		velocity = velocity.lerp(desired_velocity, 0.15)
		
		# prepare a position 3d in global coordinates
		var global_position_2d = global_transform * Vector2(position_3d.x, position_3d.y)
		var global_position_3d = Vector3(global_position_2d.x, global_position_2d.y, position_3d.z)
		
		# gravity velocity
		for well in gravity_wells:
			velocity += well.get_force(global_position_3d) * delta
			#var well_diff = well.global_position - surface_position
			#if well_diff.length() < well.get_influence_radius():
				#velocity += well_diff * global.sigmoid(well_diff.length(), well.get_influence_radius()) * well.get_gravity() * MULTIPLIER * delta
		#
		velocity = velocity.normalized() * min(velocity.length(), max_velocity)
		position_3d += velocity * delta
		
		position = Vector2(position_3d.x, position_3d.y - position_3d.z * 0.5)
		
	func rest():
		position = Vector2(anchor.x, anchor.y)
		position_3d = anchor
		velocity = Vector3.ZERO
	
	func is_at_rest():
		return (anchor - position_3d).length() < 1 && velocity.length() < 1
		
	func x():
		return position.x
	
	func y():
		return position.y
"

[node name="GridLines" type="Node2D"]
light_mask = 3
script = SubResource("GDScript_1vrqt")

[node name="Outline" type="Line2D" parent="."]
unique_name_in_owner = true
light_mask = 3
closed = true
